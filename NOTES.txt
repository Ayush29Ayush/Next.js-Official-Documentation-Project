Official Next.js Documentation Project

#? Chapter 1: Getting Started

#! Summary of the Folder Structure for a Next.js App
The sources describe a Next.js application that has the following folder structure:

/app: This folder is the heart of your Next.js application. It's where you'll put all the components, routes, and logic that make your app function. 
/app/lib: Think of this folder as your toolbox. It stores reusable functions that are used throughout your application. This includes utility functions (like formatting dates or validating data) and functions for fetching data from APIs or databases. 
/app/ui: This is where you'll organize the building blocks of your user interface. The /app/ui folder contains components like buttons, cards, forms, tables â€“ essentially, any reusable UI element. The tutorial notes that these components are pre-styled, which can save you time and effort. 
/public: This folder houses all the static assets that your application needs. These assets could be images, fonts, icons, or any other file that should be directly accessible to the browser. 
Config Files: Next.js projects include configuration files, such as next.config.js, at the root level. The sources mention that these files are typically created and pre-configured for you when you start a new project using create-next-app, and you generally won't need to modify them. 
In addition to the main folder structure, the sources provide some insights into specific file examples:

/app/lib/placeholder-data.ts: This file contains placeholder data that simulates a database during development. The placeholder data is organized as JavaScript objects, each representing a table in a hypothetical database.
/app/lib/definitions.ts: If you're using TypeScript, this file is crucial. It defines the data types used throughout your application, ensuring type safety and helping to prevent errors. The sources give an example of how types for an "invoices" table might be defined in this file. 

----------------------------------------------------------------------------------------------

#? Chapter 2: CSS Styling

#! Summary of CSS Styling Options in Next.js
The sources explain that there are several ways to style a Next.js application. Here's a summary of the essential details from the sources:

Global Styles: You can use a global CSS file to apply styles across your entire application. In the example provided, a global.css file is located in the /app/ui folder, and it's imported into the root layout component (/app/layout.tsx). This allows you to set site-wide styles for elements like links, apply CSS resets, and define other common styles. 
Tailwind CSS: Tailwind is a utility-first CSS framework that encourages styling directly in your JSX markup using predefined utility classes. Next.js provides built-in support for Tailwind, and it can be automatically configured when you create a new project using create-next-app. 
Benefits of Tailwind:
Speed and Efficiency: Tailwind's utility classes allow for rapid styling without the need to write custom CSS rules for every element. 
Scalability: Tailwind helps keep your CSS bundle size manageable as your application grows because styles are applied at the element level rather than through large, cascading stylesheets. 
Example: The sources demonstrate how to use Tailwind classes to style elements, such as adding the class "text-blue-500" to an <h1> tag to make the text blue. 
CSS Modules: CSS Modules offer a way to scope CSS styles to specific components, preventing style collisions and making your styles more maintainable. While the sources primarily focus on Tailwind, they also provide an example of how to use CSS Modules. 
Creating CSS Modules: You create a CSS module file with the .module.css extension (e.g., home.module.css). The styles within this file are locally scoped to the component where they are imported. 
Importing and Using Styles: You import the CSS module into your component and access the generated class names through an object. This helps ensure that the styles are only applied to the intended elements. 
clsx Library for Conditional Styling: The clsx library is helpful for dynamically applying CSS classes based on conditions, such as component state. You can use clsx to build up a string of class names that will be applied to an element, conditionally including or excluding classes based on logic. 
Other Styling Solutions: The sources briefly mention that you can explore other CSS solutions in Next.js:
Sass: You can use Sass, a CSS preprocessor, by importing .css and .scss files. This provides features like variables, nesting, and mixins to enhance your CSS development. 
CSS-in-JS Libraries: Libraries like styled-jsx, styled-components, and emotion enable you to write CSS-like syntax within your JavaScript components. 
Key Takeaways

Next.js provides flexibility in choosing a CSS styling approach. Tailwind and CSS Modules are recommended for their speed, scalability, and maintainability. 
Global styles can be used for site-wide styling, while Tailwind excels at quick and efficient styling directly in JSX. 
CSS Modules are excellent for scoping styles and avoiding conflicts, especially in larger projects. 
The clsx library provides a convenient way to handle conditional class names based on your application's logic. 
This information from the sources should give you a good foundation for understanding the different CSS styling options available in Next.js.

----------------------------------------------------------------------------------------------

#? Chapter 3: Optimizing Fonts and Images

#! The sources provide a detailed explanation of how to optimize fonts and images in a Next.js application. 
Let's break down the key concepts and steps:

a) Font Optimization
Why Optimize Fonts?

Performance Impact: Custom fonts can significantly affect a website's loading speed because font files need to be fetched from a server. 
Cumulative Layout Shift (CLS): When a browser renders text using a fallback font and then switches to the custom font after it loads, the text's size and layout can change. This shift in layout is called CLS, and it negatively impacts user experience. 
Next.js Font Optimization Features 

Build-Time Font Download: Next.js optimizes fonts by downloading them during the build process and hosting them with the application's static assets.
Reduced Network Requests: This approach eliminates the need for additional network requests to fetch fonts when a user visits your site, leading to faster loading times.
Adding a Custom Font 

Create a fonts.ts File: Create a file named fonts.ts within the /app/ui folder to store your application's fonts. This helps centralize font management.
Import the Inter Font: Using the next/font/google module, import the Inter font. Specify the desired subset (e.g., 'latin') to control which characters are loaded.
// /app/ui/fonts.ts
"import { Inter } from 'next/font/google';
export const inter = Inter({ subsets:  });
"
Apply the Font to the <body>: In your root layout component (/app/layout.tsx), add the inter.className to the <body> tag to apply the font globally. You can also include additional classes, like Tailwind's antialiased class for smoother font rendering.
// /app/layout.tsx
"
import '@/app/ui/global.css';
import { inter } from '@/app/ui/fonts';

export default function RootLayout({
    children,
}: {
    children: React.ReactNode;
}) {
    return (
        <html lang="en">
            <body className={`${inter.className} antialiased`}>{children}</body>
        </html>
    );
}
"
Verification: To confirm that the font is applied, use your browser's developer tools to inspect the <body> element. You should see Inter and Inter_Fallback listed under the styles. 
Adding a Secondary Font 

Import Lusitana Font: In the fonts.ts file, import the secondary font, Lusitana, from next/font/google. Make sure to specify the subset and font weight (refer to the Google Fonts website or TypeScript errors for available options).
Apply to Specific Element(s): Apply the lusitana.className to the desired elements in your application (e.g., the <p> element in app/page.tsx).
Additional Tips 

Consult the Google Fonts website to explore font options and available weights.
Refer to the Next.js documentation for details on adding multiple fonts and advanced configuration.


b) Image Optimization
Why Optimize Images? 

Images are often the largest assets on a website. 
Unoptimized images lead to slow loading times and a poor user experience. 
Challenges with Traditional Image Handling 

Responsiveness: Ensuring images adapt to various screen sizes can be complex.
Size Management: Specifying different image sizes for different devices is often manual.
Layout Shift: Images loading at different times can cause disruptive layout shifts.
Lazy Loading: Implementing lazy loading to improve initial page load times requires extra effort.
Next.js Image Optimization with the <Image> Component 

The next/image component extends the standard HTML <img> tag, providing automatic image optimization features:

Layout Shift Prevention: The component reserves space for images, preventing layout shifts as they load. 
Automatic Resizing: Images are resized to fit different viewports, reducing the need to deliver large images to devices with smaller screens. 
Built-in Lazy Loading: Images are lazy-loaded by default, meaning they load only when they enter the user's viewport. This optimizes initial page load time. 
Modern Format Support: The component serves images in modern formats like WebP and AVIF when supported by the browser, improving image quality and compression. 

Adding an Image 
Import the <Image> component: Import the Image component from next/image into the file where you want to use it.
Use the Component: Add the <Image> component, providing the src, width, height, and alt attributes. Ensure the width and height attributes match the aspect ratio of the source image to prevent layout shift.
// /app/page.tsx
import Image from 'next/image';

// ...
<Image
    src="/hero-desktop.png"
    width={1000}
    height={760}
    className="hidden md:block"
    alt="Screenshots of the dashboard project showing desktop version"
/>
Handling Different Images for Mobile and Desktop 

Provide Separate Images: Place different images for desktop and mobile in the /public folder (e.g., hero-desktop.png and hero-mobile.png).
Conditional Rendering: Use CSS classes like hidden and md:block to control the display of images based on screen size. For example, hidden md:block would hide the image on mobile and show it on desktop.

----------------------------------------------------------------------------------------------

#? Chapter 4: Creating Layouts and Pages

Creating Layouts and Pages in Next.js
This section of the documentation explains how to use Next.js features to structure your application with multiple routes and layouts for a better user experience. Here is a breakdown of the key concepts.

File-System Routing
Next.js uses a file-system based routing system, where folders represent route segments. Each folder within the /app directory maps to a corresponding URL segment in your application. For example:

The /app/dashboard folder corresponds to the /dashboard route.
A file named page.tsx within the /app/dashboard folder would be the page accessible at the /dashboard URL.
The page.tsx File
The page.tsx file is a special Next.js file that defines the content of a page. It exports a React component which is rendered when a user visits the corresponding route. Every route must have a page.tsx file to be accessible. Your application's home page is defined in the /app/page.tsx file, which is associated with the root route (/).

Creating Nested Routes
To create a nested route in your application, you simply create a new folder within an existing route folder and add a page.tsx file inside the new folder. For example, to create a page accessible at /dashboard/customers, you would:

Create a folder named customers inside the /app/dashboard folder.
Create a file named page.tsx within the /app/customers folder and define the content for the customers page.
Colocation
Next.js promotes the concept of "colocation," which means keeping related files together. You can place components, test files, and other code related to a specific route within the same folder as the page.tsx file. However, only the code within page.tsx is publicly accessible. This helps to organize your project and make it easier to maintain.

Layouts
Layouts allow you to create shared UI elements that are common across multiple pages. Next.js uses a special file named layout.tsx for defining layouts. A layout.tsx file exports a React component that receives a children prop. The content of the page.tsx file for the corresponding route is rendered as the children within the layout.

Nested Layouts
Layouts can be nested to create a hierarchy of shared UI components. For example, you can create a layout specific to your dashboard pages at /app/dashboard/layout.tsx that wraps the content of all pages within the /dashboard route. This allows you to have a consistent navigation or sidebar across all dashboard pages.

Partial Rendering
When navigating between pages that share a common layout, Next.js only updates the content within the page.tsx file while the layout component remains unchanged. This optimization, called partial rendering, improves performance by avoiding unnecessary re-renders of the entire page.

Root Layout
The root layout, located at /app/layout.tsx, is a special layout that wraps all pages in your application. It's primarily used for applying global styles and settings, like importing fonts or defining metadata. The root layout is required in every Next.js application.

----------------------------------------------------------------------------------------------

#? Chapter 5: Navigating Between Pages

Next.js Navigation Optimization
This section of the documentation explains how Next.js optimizes navigation between pages in an application to provide a smooth user experience that feels more like a web app than a traditional website.

Traditional Navigation Drawbacks: Using standard <a> HTML elements for navigation causes a full page refresh every time a user clicks a link. This leads to a less responsive experience and can feel jarring to the user.
The Link Component: Next.js provides a <Link /> component that enables client-side navigation with JavaScript, eliminating the full page refresh issue. The syntax is similar to using an <a> tag, simply replacing <a href="..."> with <Link href="...">. 

Automatic Code Splitting and Prefetching: Next.js enhances performance by automatically splitting your application's code into smaller chunks based on route segments. Unlike traditional single-page applications (SPAs) where the entire application code is loaded upfront, Next.js only loads the code needed for the current route. This results in faster initial page loads and better resource management. 
Route Isolation: Code splitting isolates pages, so an error on one page won't affect the functionality of other parts of the application.
Prefetching: When a <Link> component appears in the viewport, Next.js prefetches the code for the linked route in the background. This means that when a user clicks the link, the page transition is almost instantaneous because the code is already loaded.
Active Link Styling: A common UI pattern is to highlight the currently active link in the navigation menu.
usePathname() hook: You can use the usePathname() hook from next/navigation to get the user's current path from the URL. Since this is a hook, the component where you use it must be a Client Component. You indicate a component is a Client Component by adding "use client" to the top of the file.
Conditional Styling: By comparing the value returned by usePathname() to the href attribute of your <Link> components, you can apply CSS classes to style the active link. This helps users easily understand their current location within the application.

#? Chapter 6: Setting Up Your Database

This section of the sources provides a step-by-step guide on setting up a PostgreSQL database for your Next.js application using Vercel's marketplace integrations. It assumes you are using GitHub for your repository, but alternatives like GitLab or Bitbucket are also compatible. The instructions walk through pushing your project to GitHub, creating a Vercel account, deploying your project, and setting up and seeding your database.

Connecting your Project to GitHub and Vercel
1. Push Your Code to a GitHub Repository: If you haven't already, start by pushing your Next.js project to a GitHub repository. This step is essential for seamless integration with Vercel's deployment and database provisioning tools. 

2. Sign Up for Vercel and Link Your GitHub Account: Create a free "hobby" plan account on Vercel by visiting vercel.com/signup. To connect your GitHub and Vercel accounts, select the "Continue with GitHub" option. 

3. Import and Deploy Your Project: After connecting your accounts, Vercel will prompt you to import the GitHub repository you created. Choose a name for your project and click "Deploy" to initiate the deployment process. This action creates a live version of your application hosted on Vercel's platform. 

Automatic Redeployment on GitHub Push: Connecting your GitHub repository to Vercel enables automatic redeployment whenever you push changes to the main branch. Additionally, creating pull requests will generate instant previews, allowing you to catch deployment errors early and share a preview of your project with your team for feedback. 

Creating and Seeding your PostgreSQL Database
1. Create a PostgreSQL Database: Go to the "Storage" tab in your Vercel project dashboard and click "Create Database." You'll have options to choose from Postgres (Powered by Neon), Neon, or Supabase. Select your preferred provider and proceed by clicking "Continue." 

2. Connect to the Database and Configure Environment Variables: Accept the terms of service, choose your desired region (Washington D.C. (iad1) is recommended for lower latency), and select a plan if needed. After successfully connecting, go to the .env.local tab within your Vercel dashboard, click "Show secret" to reveal your database credentials, and then click "Copy Snippet." In your code editor, locate the .env.example file and rename it to .env. Paste the copied content from Vercel into this file. 

Protect your Secrets: To prevent your database credentials from being exposed when pushing to GitHub, add the .env file to your .gitignore file. 

3. Install the Vercel Postgres SDK: Execute the command "pnpm i @vercel/postgres" in your terminal to install the Vercel Postgres SDK. This SDK simplifies database interactions within your Next.js application. 

4. Seed Your Database with Initial Data: Within the /app folder of your project, you'll find a /seed folder that contains a Next.js Route Handler (route.ts). Uncomment this file. This handler acts as a server-side endpoint designed to populate your database. It uses SQL to create the necessary tables and draws data from the placeholder-data.ts file to fill them. 

5. Run the Seed Script: Ensure that your local development server is running (using pnpm run dev) and then visit localhost:3000/seed in your web browser. You should see a message confirming "Database seeded successfully." Once seeding is complete, you can safely delete the seed file. 

Additional Information about the Database
The sources mention that the seeding script uses the bcrypt library to hash user passwords for security purposes. If you encounter compatibility issues with bcrypt in your development environment, you can modify the script to use bcryptjs instead. 

Troubleshooting Database Seeding: The sources offer some troubleshooting tips for common database seeding issues. If you need to rerun the seeding script and there are existing tables, you can remove them using the DROP TABLE tablename command in your database query interface. However, exercise caution as this command will delete the specified table and all its associated data. While this is acceptable in a development environment with placeholder data, avoid using it in production applications. 

Executing Queries to Test the Setup: To verify that everything is functioning correctly, you can execute queries using another Router Handler located at /query/route.ts. This file contains a listInvoices() function with a sample SQL query. Uncomment this file and visit localhost:3000/query in your browser. The page should display the results of the query, returning an invoice amount and name. 

Conclusion
By following these steps, you'll have a PostgreSQL database set up and integrated into your Next.js project, ready for you to continue building your application.


-------------------------------------------------------------------------------------------------------------------------------

#? Chapter 7: Fetching Data in Next.js
This section of the Next.js documentation explores various data fetching methods for building applications, focusing on the advantages of Server Components and SQL queries for efficient data handling. 

Choosing How to Fetch Data
API Layer: 
Acts as an intermediary between your application and database.
Useful when:
Using third-party services that offer an API.
Fetching data from the client while protecting database secrets.
Next.js enables API endpoint creation using Route Handlers.
Database Queries: 
Direct interaction with the database, especially for full-stack applications using relational databases like Postgres.
Options include using SQL or an ORM (Object-Relational Mapping).
Direct Database Queries (Server Components): 
Server Components allow querying the database directly without an API layer, enhancing security by keeping database secrets on the server.
Benefits of Using Server Components for Data Fetching
Simplified Asynchronous Operations: 
Native support for promises and async/await syntax eliminates the need for useEffect, useState, or data fetching libraries.
Server-Side Execution: 
Keeps resource-intensive data fetching and logic on the server, reducing client-side load and improving performance.
Enhanced Security: 
Direct database queries within Server Components eliminate the need for an API layer, protecting sensitive database information.
Using SQL for Database Queries
This section advocates for using SQL for database interactions due to its advantages: 

Industry Standard: SQL is widely used for querying relational databases, forming the foundation of even ORMs.
Foundational Understanding: Basic SQL knowledge provides insights into relational databases, applicable to other tools.
Versatility: SQL offers flexibility in fetching and manipulating specific data sets.
Security: The Vercel Postgres SDK, used in the example, includes built-in protection against SQL injection attacks.
Example: Building a Dashboard Overview Page
The documentation guides users through building a dashboard page, emphasizing efficient data fetching techniques. 

Async Components: The Page component is defined as async, allowing the use of await for data fetching. 
Data Queries: The data.ts file contains functions using the sql function from @vercel/postgres to query the database. 
Component Examples: The dashboard includes components like <Card>, <RevenueChart>, and <LatestInvoices>, each fetching data using SQL queries. 
Addressing Request Waterfalls
The document highlights the issue of request waterfalls, where data requests execute sequentially, potentially impacting performance. 

Explanation: Waterfalls occur when each data request waits for the previous one to finish before starting. 
Example: The code demonstrates how fetchLatestInvoices() waits for fetchRevenue() to complete. 
Conditional Waterfalls: Waterfalls can be intentional when dependencies exist between requests, but unintentional waterfalls hinder performance. 
Solution: Parallel Data Fetching
The documentation suggests using Promise.all() or Promise.allSettled() to execute data requests in parallel, enhancing performance. 

JavaScript Pattern: These functions allow initiating multiple promises concurrently, irrespective of libraries or frameworks. 
Example: The fetchCardData() function utilizes Promise.all() to execute three SQL queries simultaneously. 
Potential Disadvantage: A single slow request can still delay the overall process, even with parallel fetching. 
Note: The provided source excerpts do not explain how to address the issue of static rendering and data updates mentioned in point 2 of source . This topic is likely covered in the subsequent chapter.

------------------------------------------------------------------------------------------------------------

#? Chapter 8: Static and Dynamic Rendering

Understanding Static and Dynamic Rendering in Next.js
This section of the Next.js documentation explores the concepts of static rendering and dynamic rendering, two fundamental approaches to rendering web pages and handling data in Next.js applications.

Static Rendering
Definition: Static rendering involves fetching data and generating the HTML content of a page at build time (when you deploy the application) or during data revalidation. The generated HTML is then cached and served to users upon request. 
Benefits:Performance: Faster loading times due to cached content and global distribution through content delivery networks (CDNs). 
Reduced server load: The server doesn't need to dynamically generate content for each request. 
Improved SEO: Search engine crawlers can easily index the pre-rendered content. 
Use Cases: Static rendering is well-suited for pages with no data or data that is shared across users, such as blog posts, product pages, or marketing landing pages. 
Limitations: Static rendering may not be ideal for pages requiring personalized or frequently updated data, like dashboards or user profiles. 

Dynamic Rendering
Definition: Dynamic rendering generates the HTML content of a page on the server for each user request. 
Benefits:Real-time data: Ability to display frequently updated data. 
User-specific content: Facilitates personalized content like dashboards or user profiles. 
Access to request-time information: Allows utilizing information like cookies or URL search parameters. 
Use Cases: Dynamic rendering is suitable for applications requiring real-time data, personalized experiences, and access to request-specific information. 
Challenges:Performance: The application's responsiveness is limited by the slowest data fetch operation. 
Increased server load: The server needs to process each request individually.

Simulating Slow Data Fetch
The documentation provides an example to illustrate the impact of slow data fetching on dynamic rendering. 

Code Modification: A 3-second delay is introduced in the fetchRevenue() function using setTimeout() to simulate a slow data fetch. 
Observation: The page load time increases significantly, as the entire page rendering is blocked until the slow data fetch completes. 
Key Takeaway: This example emphasizes the importance of optimizing data fetching operations in dynamic rendering, as the slowest fetch can bottleneck the entire application. 
Moving Forward
The documentation hints at the potential for a more detailed discussion about addressing data update issues with static rendering in the subsequent chapter on streaming.  However, specific solutions for this limitation are not explicitly provided in the given source excerpts.

------------------------------------------------------------------------------------------------

#? Chapter 9: Streaming

This section of the Next.js documentation introduces streaming, a technique for improving user experience by breaking down a route into smaller chunks and progressively sending them from the server to the client. This allows users to interact with parts of the page while other parts are still loading, instead of waiting for the entire page to load.

Implementing Streaming
Next.js offers two ways to implement streaming:

Page-level streaming with loading.tsx: This approach uses a special file named loading.tsx to create fallback UI that is displayed while the page content loads. 
Component-level streaming with <Suspense>: This method allows streaming specific components by wrapping them in the <Suspense> component. A fallback component can be provided to display while the dynamic component loads. 
loading.tsx and Loading Skeletons
The loading.tsx file acts as a wrapper around the page content and is based on React's Suspense feature. 
Any UI added within loading.tsx is embedded in the static file sent first to the client, providing immediate feedback to the user. 
Loading skeletons, simplified versions of the UI, are often used as placeholders in loading.tsx to indicate loading content. 
Route Groups
Route groups help organize files logically without affecting the URL structure. 
They are created by placing files within a folder named with parentheses, e.g., (overview). The parenthesized name is not included in the URL path. 
Route groups can limit the scope of loading.tsx to specific sections of an application. 
Streaming a Component
Streaming individual components is achieved by wrapping the component in <Suspense> and providing a fallback component. 
The data fetching logic is moved from the page level down to the component level. 
Grouping Components
Wrapping multiple components in a single <Suspense> boundary can prevent a "popping" effect where components load in one by one. 
Creating a wrapper component for related components allows them to load together and provides a smoother visual experience. 
Deciding Where to Place Suspense Boundaries
The placement of Suspense boundaries depends on several factors: 
Desired user experience during streaming.
Content prioritization.
Data fetching requirements of components.
Streaming Strategies
The sources outline various strategies for streaming, each with advantages and disadvantages:

Whole page streaming: Offers simplicity but can be slow if a component has a slow data fetch. 
Individual component streaming: Allows for fine-grained control but may result in a jarring "popping" effect. 
Page section streaming: Provides a balanced approach by streaming groups of related components. 
The best strategy depends on the specific application. 

---------------------------------------------------------------------------------------------

#? Chapter 10: Partial Prerendering

Refer => https://nextjs.org/learn/dashboard-app/partial-prerendering

---------------------------------------------------------------------------------------------

#? Chapter 11: Adding Search and Pagination

This section of the Learn Next.js tutorial explains how to implement search and pagination functionalities in a Next.js application using URL search parameters. It emphasizes the benefits of utilizing URL search parameters over client-side state management and provides step-by-step instructions for integrating these features.

Advantages of Using URL Search Params
The tutorial advocates for using URL search params for managing search and pagination states because of several key benefits :

Bookmarkable and Shareable URLs: Users can bookmark or share URLs that retain their search queries and filters .
Server-Side Rendering and Initial Load: The server can directly use URL parameters to pre-render the initial state of the page, improving SEO and perceived performance .
Analytics and Tracking: Search queries and filters in the URL streamline user behavior tracking without requiring complex client-side logic .
Adding Search Functionality
The tutorial outlines the following steps for adding search functionality:

Capture User Input: Implement an input field in a Client Component (e.g., <Search>) and use the onChange event listener to capture user input .
Update the URL with Search Params:Use the useSearchParams hook from 'next/navigation' to access current URL parameters .
Create a new URLSearchParams instance to manipulate the query parameters .
Use the set method to add the search term to the parameters or delete to remove it if the input is empty .
Utilize the useRouter and usePathname hooks to update the URL using the replace method, which modifies the URL without a full page reload .
Keep URL and Input Field Synced: Utilize the defaultValue attribute of the input field to populate it with the search query from the URL, ensuring consistency .
The tutorial explains the distinction between defaultValue and value, highlighting that defaultValue is suitable when not using state management for the input value, as the native input manages its state .
Update the Table Component: Pass the updated searchParams to the Server Component responsible for displaying data (e.g., <Table>) so it can fetch and render the filtered results .
The tutorial differentiates between using the useSearchParams hook in Client Components and accessing searchParams via props in Server Components .
Optimizing Search with Debouncing
The tutorial highlights the potential performance issue of triggering a server request with every keystroke and introduces debouncing as a solution :

Debouncing: A technique that limits the rate at which a function executes, in this case, preventing excessive database queries with each keystroke .
Implementation: The tutorial suggests using the "use-debounce" library and provides code examples for incorporating it into the search functionality .
Adding Pagination
The tutorial then explains how to implement pagination using URL search parameters, following a similar approach to the search implementation :

Fetch Total Pages: A server-side function, fetchInvoicesPages, calculates the total number of pages based on the search query and the number of items displayed per page .
Pass Total Pages to Pagination Component: The calculated totalPages value is passed as a prop to the <Pagination> Client Component .
Implement Pagination Logic: The <Pagination> component utilizes usePathname and useSearchParams hooks to manage the current page and generate URLs for different pages .
Reset Page on New Search: Modify the handleSearch function to set the page number back to 1 whenever a new search query is entered, ensuring users start from the first page of the new results .
Summary
The tutorial concludes by summarizing the key concepts covered:

Managing search and pagination with URL search parameters instead of client-side state .
Fetching data on the server to avoid exposing sensitive information .
Leveraging the useRouter hook for client-side transitions without full page reloads .
By implementing these techniques, you can create a more efficient and user-friendly application with seamless search and pagination features.

-----------------------------------------------------------------------------------------------

#? Chapter 12: Mutating Data

This section of the Learn Next.js tutorial focuses on Server Actions, a powerful feature in Next.js for handling data mutations, such as creating, updating, and deleting data. The tutorial explains how Server Actions streamline data manipulation, enhances security, and integrates seamlessly with Next.js caching mechanisms.

What are Server Actions? 
Server Actions are asynchronous functions that run directly on the server, eliminating the need for separate API endpoints for data mutations. 
They can be invoked from both Client and Server Components. 
They offer significant security advantages by protecting against various web application threats through: 
POST requests
Encrypted closures
Strict input checks
Error message hashing
Host restrictions
Using Forms with Server Actions 
Server Actions can be invoked from forms by utilizing the action attribute of the <form> element. 
The action automatically receives the native FormData object, which contains the submitted data. 
Example: 
// Server Component

export default function Page() {

  // Action

  async function create(formData: FormData) {

    'use server';

    // Logic to mutate data...

  }

  // Invoke the action using the "action" attribute

  return <form action={create}>...</form>;

}

Invoking a Server Action within a Server Component allows for progressive enhancement, enabling forms to function even if JavaScript is disabled on the client. 
Server Actions and Next.js Caching 
Server Actions integrate deeply with Next.js caching mechanisms. 
When a form is submitted through a Server Action, the action can mutate data and revalidate the associated cache using APIs like revalidatePath and revalidateTag. 
Creating an Invoice: A Step-by-Step Guide 
The tutorial provides a practical example of creating an invoice to demonstrate the usage of Server Actions, outlining the following steps: 

Create a form to capture user input. 
Create a Server Action and invoke it from the form. 
Inside the Server Action, extract data from the formData object. 
Validate and prepare the data for database insertion. 
Insert the data into the database and handle any errors. 
Revalidate the cache and redirect the user to the invoices page. 
1. Creating the Route and Form 
Create a new route segment /create with a page.tsx file within the /invoices folder. 
The provided code snippet demonstrates a Server Component that fetches customer data and passes it to a <Form> component. 
The <Form> component: 
Includes a dropdown (<select>) for selecting customers. 
Uses input fields (<input>) for entering the amount and status. 
Has a submit button (<button type="submit">). 
2. Creating the Server Action 
Create a new file named actions.ts in the lib directory. 
Add the 'use server' directive to the top of the file to mark all exported functions as Server Actions. 
Create an asynchronous function createInvoice that accepts formData as a parameter. 
Import the createInvoice function into the <Form> component and call it using the action attribute of the form element. 
Important Note: 

In HTML, the action attribute typically specifies a URL for submitting form data. 
In React, the action attribute is a special prop for invoking actions. 
Server Actions automatically create a POST API endpoint behind the scenes. 
3. Extracting Data from formData 
Inside the actions.ts file, extract the values from formData using methods like .get(name) or entries(). 
Example using .get(name): 
const rawFormData = {

  customerId: formData.get('customerId'),

  amount: formData.get('amount'),

  status: formData.get('status'),

};

Using entries() and Object.fromEntries(): 
const rawFormData = Object.fromEntries(formData.entries());

4. Validating and Preparing the Data 
Type validation and coercion: 
Validate the data types from the form to match the database expectations. 
Use a type validation library like Zod to simplify validation and coercion. 
Define a Zod schema that matches the form object structure. 
Use z.coerce.number() to convert string values to numbers, ensuring type correctness. 
Storing values in cents: 
Convert monetary values to cents before storing in the database to prevent floating-point errors. 
Multiply the amount by 100 to get the value in cents. 
Creating new dates: 
Create a new date in the format "YYYY-MM-DD" for the invoice creation date. 
5. Inserting Data into the Database 
Construct an SQL query to insert the validated and prepared data into the database using the sql tag from @vercel/postgres. 
6. Revalidating and Redirecting 
Use revalidatePath from next/cache to clear the Next.js Client-side Router Cache and trigger a fresh data fetch for the specified path (e.g., /dashboard/invoices). 
Utilize redirect from next/navigation to redirect the user to the desired page after the database update. 
Updating an Invoice 
The tutorial then explains how to update an existing invoice, involving these steps: 

Create a dynamic route segment with the invoice ID. 
Read the invoice ID from the page parameters. 
Fetch the specific invoice from the database. 
Pre-populate the form with the fetched invoice data. 
Update the invoice data in the database. 
1. Creating a Dynamic Route Segment 
Create a dynamic route segment named 
Create a new route called edit with a page.tsx file within the 
2. Reading the Invoice ID 
Access the id parameter using the params prop in the page component. 
3. Fetching the Specific Invoice 
Use fetchInvoiceById function to fetch the invoice data based on the ID. 
4. Passing the ID to the Server Action 
Pass the id to the updateInvoice Server Action using bind. 
Avoid passing the id directly as an argument, as it may not be encoded properly. 
Using bind ensures that all values passed to the Server Action are encoded. 
Alternatively, you can use a hidden input field to pass the id, but be mindful of potential security concerns with sensitive data in the HTML source. 
Deleting an Invoice 
Wrap the delete button within a <form> element. 
Use bind to pass the id to the deleteInvoice Server Action. 
Create the deleteInvoice Server Action in actions.ts. 
Call revalidatePath to refresh the invoices page after deletion. 
This section of the Next.js tutorial offers a comprehensive guide to utilizing Server Actions for efficient and secure data mutations in Next.js applications. Remember to refer to the original sources for specific code examples and implementation details.

-----------------------------------------------------------------------------------------------

#? Chapter 13: handling Errors

This section explains how to handle errors gracefully in Next.js applications.

Error Handling with try...catch and error.tsx
First, add a try...catch block to Server Actions to handle errors gracefully. 
The redirect function should be called outside the try...catch block because it throws an error that could be caught by the catch block. 
To simulate an error, you can throw an error at the beginning of a Server Action, like the deleteInvoice action. 
The error.tsx file is a UI boundary for a route segment that catches unexpected errors and displays a fallback UI to users. It's a catch-all for errors. 
Create an error.tsx file in the /dashboard/invoices folder. 
The error.tsx file needs to be a Client Component and should use the "use client" directive. 
It takes two props: error (an instance of the JavaScript Error object) and reset (a function to reset the error boundary and re-render the route segment). 
Handling 404 Errors with the notFound Function
The notFound function is used to handle cases where you try to fetch a resource that doesn't exist, providing a more specific error handling mechanism than error.tsx. 
You can use a fake UUID that doesn't exist in your database to test 404 errors. 
In this case, error.tsx will be invoked because it's defined in the parent route. 
To handle 404 errors specifically, you can use the notFound function. 
Confirm that the resource is not found by checking the returned value in the fetchInvoiceById function. 
Import { notFound } from 'next/navigation' in the relevant page component. 
Use a conditional statement to invoke notFound if the invoice doesn't exist. 
Create a not-found.tsx file inside the /edit folder to display a 404 error UI. 
The notFound function takes precedence over error.tsx for specific error handling. 

-----------------------------------------------------------------------------------------------

#? Chapter 14: Improving Asccessibility

* Adding Accessibility to Your Next.js Application, refer documentation

----------------------------------------------------------------------------------------------