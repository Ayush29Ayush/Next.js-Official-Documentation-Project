Official Next.js Documentation Project

#? Getting Started

#! Summary of the Folder Structure for a Next.js App
The sources describe a Next.js application that has the following folder structure:

/app: This folder is the heart of your Next.js application. It's where you'll put all the components, routes, and logic that make your app function. 
/app/lib: Think of this folder as your toolbox. It stores reusable functions that are used throughout your application. This includes utility functions (like formatting dates or validating data) and functions for fetching data from APIs or databases. 
/app/ui: This is where you'll organize the building blocks of your user interface. The /app/ui folder contains components like buttons, cards, forms, tables â€“ essentially, any reusable UI element. The tutorial notes that these components are pre-styled, which can save you time and effort. 
/public: This folder houses all the static assets that your application needs. These assets could be images, fonts, icons, or any other file that should be directly accessible to the browser. 
Config Files: Next.js projects include configuration files, such as next.config.js, at the root level. The sources mention that these files are typically created and pre-configured for you when you start a new project using create-next-app, and you generally won't need to modify them. 
In addition to the main folder structure, the sources provide some insights into specific file examples:

/app/lib/placeholder-data.ts: This file contains placeholder data that simulates a database during development. The placeholder data is organized as JavaScript objects, each representing a table in a hypothetical database.
/app/lib/definitions.ts: If you're using TypeScript, this file is crucial. It defines the data types used throughout your application, ensuring type safety and helping to prevent errors. The sources give an example of how types for an "invoices" table might be defined in this file. 

----------------------------------------------------------------------------------------------

#? CSS Styling

Summary of CSS Styling Options in Next.js
The sources explain that there are several ways to style a Next.js application. Here's a summary of the essential details from the sources:

Global Styles: You can use a global CSS file to apply styles across your entire application. In the example provided, a global.css file is located in the /app/ui folder, and it's imported into the root layout component (/app/layout.tsx). This allows you to set site-wide styles for elements like links, apply CSS resets, and define other common styles. 
Tailwind CSS: Tailwind is a utility-first CSS framework that encourages styling directly in your JSX markup using predefined utility classes. Next.js provides built-in support for Tailwind, and it can be automatically configured when you create a new project using create-next-app. 
Benefits of Tailwind:
Speed and Efficiency: Tailwind's utility classes allow for rapid styling without the need to write custom CSS rules for every element. 
Scalability: Tailwind helps keep your CSS bundle size manageable as your application grows because styles are applied at the element level rather than through large, cascading stylesheets. 
Example: The sources demonstrate how to use Tailwind classes to style elements, such as adding the class "text-blue-500" to an <h1> tag to make the text blue. 
CSS Modules: CSS Modules offer a way to scope CSS styles to specific components, preventing style collisions and making your styles more maintainable. While the sources primarily focus on Tailwind, they also provide an example of how to use CSS Modules. 
Creating CSS Modules: You create a CSS module file with the .module.css extension (e.g., home.module.css). The styles within this file are locally scoped to the component where they are imported. 
Importing and Using Styles: You import the CSS module into your component and access the generated class names through an object. This helps ensure that the styles are only applied to the intended elements. 
clsx Library for Conditional Styling: The clsx library is helpful for dynamically applying CSS classes based on conditions, such as component state. You can use clsx to build up a string of class names that will be applied to an element, conditionally including or excluding classes based on logic. 
Other Styling Solutions: The sources briefly mention that you can explore other CSS solutions in Next.js:
Sass: You can use Sass, a CSS preprocessor, by importing .css and .scss files. This provides features like variables, nesting, and mixins to enhance your CSS development. 
CSS-in-JS Libraries: Libraries like styled-jsx, styled-components, and emotion enable you to write CSS-like syntax within your JavaScript components. 
Key Takeaways

Next.js provides flexibility in choosing a CSS styling approach. Tailwind and CSS Modules are recommended for their speed, scalability, and maintainability. 
Global styles can be used for site-wide styling, while Tailwind excels at quick and efficient styling directly in JSX. 
CSS Modules are excellent for scoping styles and avoiding conflicts, especially in larger projects. 
The clsx library provides a convenient way to handle conditional class names based on your application's logic. 
This information from the sources should give you a good foundation for understanding the different CSS styling options available in Next.js.

----------------------------------------------------------------------------------------------

#? Optimizing Fonts and Images

The sources provide a detailed explanation of how to optimize fonts and images in a Next.js application. Let's break down the key concepts and steps:

a) Font Optimization
Why Optimize Fonts?

Performance Impact: Custom fonts can significantly affect a website's loading speed because font files need to be fetched from a server. 
Cumulative Layout Shift (CLS): When a browser renders text using a fallback font and then switches to the custom font after it loads, the text's size and layout can change. This shift in layout is called CLS, and it negatively impacts user experience. 
Next.js Font Optimization Features 

Build-Time Font Download: Next.js optimizes fonts by downloading them during the build process and hosting them with the application's static assets.
Reduced Network Requests: This approach eliminates the need for additional network requests to fetch fonts when a user visits your site, leading to faster loading times.
Adding a Custom Font 

Create a fonts.ts File: Create a file named fonts.ts within the /app/ui folder to store your application's fonts. This helps centralize font management.
Import the Inter Font: Using the next/font/google module, import the Inter font. Specify the desired subset (e.g., 'latin') to control which characters are loaded.
// /app/ui/fonts.ts
"import { Inter } from 'next/font/google';
export const inter = Inter({ subsets:  });
"
Apply the Font to the <body>: In your root layout component (/app/layout.tsx), add the inter.className to the <body> tag to apply the font globally. You can also include additional classes, like Tailwind's antialiased class for smoother font rendering.
// /app/layout.tsx
"
import '@/app/ui/global.css';
import { inter } from '@/app/ui/fonts';

export default function RootLayout({
    children,
}: {
    children: React.ReactNode;
}) {
    return (
        <html lang="en">
            <body className={`${inter.className} antialiased`}>{children}</body>
        </html>
    );
}
"
Verification: To confirm that the font is applied, use your browser's developer tools to inspect the <body> element. You should see Inter and Inter_Fallback listed under the styles. 
Adding a Secondary Font 

Import Lusitana Font: In the fonts.ts file, import the secondary font, Lusitana, from next/font/google. Make sure to specify the subset and font weight (refer to the Google Fonts website or TypeScript errors for available options).
Apply to Specific Element(s): Apply the lusitana.className to the desired elements in your application (e.g., the <p> element in app/page.tsx).
Additional Tips 

Consult the Google Fonts website to explore font options and available weights.
Refer to the Next.js documentation for details on adding multiple fonts and advanced configuration.


b) Image Optimization
Why Optimize Images? 

Images are often the largest assets on a website. 
Unoptimized images lead to slow loading times and a poor user experience. 
Challenges with Traditional Image Handling 

Responsiveness: Ensuring images adapt to various screen sizes can be complex.
Size Management: Specifying different image sizes for different devices is often manual.
Layout Shift: Images loading at different times can cause disruptive layout shifts.
Lazy Loading: Implementing lazy loading to improve initial page load times requires extra effort.
Next.js Image Optimization with the <Image> Component 

The next/image component extends the standard HTML <img> tag, providing automatic image optimization features:

Layout Shift Prevention: The component reserves space for images, preventing layout shifts as they load. 
Automatic Resizing: Images are resized to fit different viewports, reducing the need to deliver large images to devices with smaller screens. 
Built-in Lazy Loading: Images are lazy-loaded by default, meaning they load only when they enter the user's viewport. This optimizes initial page load time. 
Modern Format Support: The component serves images in modern formats like WebP and AVIF when supported by the browser, improving image quality and compression. 

Adding an Image 
Import the <Image> component: Import the Image component from next/image into the file where you want to use it.
Use the Component: Add the <Image> component, providing the src, width, height, and alt attributes. Ensure the width and height attributes match the aspect ratio of the source image to prevent layout shift.
// /app/page.tsx
import Image from 'next/image';

// ...
<Image
    src="/hero-desktop.png"
    width={1000}
    height={760}
    className="hidden md:block"
    alt="Screenshots of the dashboard project showing desktop version"
/>
Handling Different Images for Mobile and Desktop 

Provide Separate Images: Place different images for desktop and mobile in the /public folder (e.g., hero-desktop.png and hero-mobile.png).
Conditional Rendering: Use CSS classes like hidden and md:block to control the display of images based on screen size. For example, hidden md:block would hide the image on mobile and show it on desktop.