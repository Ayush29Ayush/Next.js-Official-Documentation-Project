Official Next.js Documentation Project

#? Chapter 1: Getting Started

#! Summary of the Folder Structure for a Next.js App
The sources describe a Next.js application that has the following folder structure:

/app: This folder is the heart of your Next.js application. It's where you'll put all the components, routes, and logic that make your app function. 
/app/lib: Think of this folder as your toolbox. It stores reusable functions that are used throughout your application. This includes utility functions (like formatting dates or validating data) and functions for fetching data from APIs or databases. 
/app/ui: This is where you'll organize the building blocks of your user interface. The /app/ui folder contains components like buttons, cards, forms, tables â€“ essentially, any reusable UI element. The tutorial notes that these components are pre-styled, which can save you time and effort. 
/public: This folder houses all the static assets that your application needs. These assets could be images, fonts, icons, or any other file that should be directly accessible to the browser. 
Config Files: Next.js projects include configuration files, such as next.config.js, at the root level. The sources mention that these files are typically created and pre-configured for you when you start a new project using create-next-app, and you generally won't need to modify them. 
In addition to the main folder structure, the sources provide some insights into specific file examples:

/app/lib/placeholder-data.ts: This file contains placeholder data that simulates a database during development. The placeholder data is organized as JavaScript objects, each representing a table in a hypothetical database.
/app/lib/definitions.ts: If you're using TypeScript, this file is crucial. It defines the data types used throughout your application, ensuring type safety and helping to prevent errors. The sources give an example of how types for an "invoices" table might be defined in this file. 

----------------------------------------------------------------------------------------------

#? Chapter 2: CSS Styling

#! Summary of CSS Styling Options in Next.js
The sources explain that there are several ways to style a Next.js application. Here's a summary of the essential details from the sources:

Global Styles: You can use a global CSS file to apply styles across your entire application. In the example provided, a global.css file is located in the /app/ui folder, and it's imported into the root layout component (/app/layout.tsx). This allows you to set site-wide styles for elements like links, apply CSS resets, and define other common styles. 
Tailwind CSS: Tailwind is a utility-first CSS framework that encourages styling directly in your JSX markup using predefined utility classes. Next.js provides built-in support for Tailwind, and it can be automatically configured when you create a new project using create-next-app. 
Benefits of Tailwind:
Speed and Efficiency: Tailwind's utility classes allow for rapid styling without the need to write custom CSS rules for every element. 
Scalability: Tailwind helps keep your CSS bundle size manageable as your application grows because styles are applied at the element level rather than through large, cascading stylesheets. 
Example: The sources demonstrate how to use Tailwind classes to style elements, such as adding the class "text-blue-500" to an <h1> tag to make the text blue. 
CSS Modules: CSS Modules offer a way to scope CSS styles to specific components, preventing style collisions and making your styles more maintainable. While the sources primarily focus on Tailwind, they also provide an example of how to use CSS Modules. 
Creating CSS Modules: You create a CSS module file with the .module.css extension (e.g., home.module.css). The styles within this file are locally scoped to the component where they are imported. 
Importing and Using Styles: You import the CSS module into your component and access the generated class names through an object. This helps ensure that the styles are only applied to the intended elements. 
clsx Library for Conditional Styling: The clsx library is helpful for dynamically applying CSS classes based on conditions, such as component state. You can use clsx to build up a string of class names that will be applied to an element, conditionally including or excluding classes based on logic. 
Other Styling Solutions: The sources briefly mention that you can explore other CSS solutions in Next.js:
Sass: You can use Sass, a CSS preprocessor, by importing .css and .scss files. This provides features like variables, nesting, and mixins to enhance your CSS development. 
CSS-in-JS Libraries: Libraries like styled-jsx, styled-components, and emotion enable you to write CSS-like syntax within your JavaScript components. 
Key Takeaways

Next.js provides flexibility in choosing a CSS styling approach. Tailwind and CSS Modules are recommended for their speed, scalability, and maintainability. 
Global styles can be used for site-wide styling, while Tailwind excels at quick and efficient styling directly in JSX. 
CSS Modules are excellent for scoping styles and avoiding conflicts, especially in larger projects. 
The clsx library provides a convenient way to handle conditional class names based on your application's logic. 
This information from the sources should give you a good foundation for understanding the different CSS styling options available in Next.js.

----------------------------------------------------------------------------------------------

#? Chapter 3: Optimizing Fonts and Images

#! The sources provide a detailed explanation of how to optimize fonts and images in a Next.js application. 
Let's break down the key concepts and steps:

a) Font Optimization
Why Optimize Fonts?

Performance Impact: Custom fonts can significantly affect a website's loading speed because font files need to be fetched from a server. 
Cumulative Layout Shift (CLS): When a browser renders text using a fallback font and then switches to the custom font after it loads, the text's size and layout can change. This shift in layout is called CLS, and it negatively impacts user experience. 
Next.js Font Optimization Features 

Build-Time Font Download: Next.js optimizes fonts by downloading them during the build process and hosting them with the application's static assets.
Reduced Network Requests: This approach eliminates the need for additional network requests to fetch fonts when a user visits your site, leading to faster loading times.
Adding a Custom Font 

Create a fonts.ts File: Create a file named fonts.ts within the /app/ui folder to store your application's fonts. This helps centralize font management.
Import the Inter Font: Using the next/font/google module, import the Inter font. Specify the desired subset (e.g., 'latin') to control which characters are loaded.
// /app/ui/fonts.ts
"import { Inter } from 'next/font/google';
export const inter = Inter({ subsets:  });
"
Apply the Font to the <body>: In your root layout component (/app/layout.tsx), add the inter.className to the <body> tag to apply the font globally. You can also include additional classes, like Tailwind's antialiased class for smoother font rendering.
// /app/layout.tsx
"
import '@/app/ui/global.css';
import { inter } from '@/app/ui/fonts';

export default function RootLayout({
    children,
}: {
    children: React.ReactNode;
}) {
    return (
        <html lang="en">
            <body className={`${inter.className} antialiased`}>{children}</body>
        </html>
    );
}
"
Verification: To confirm that the font is applied, use your browser's developer tools to inspect the <body> element. You should see Inter and Inter_Fallback listed under the styles. 
Adding a Secondary Font 

Import Lusitana Font: In the fonts.ts file, import the secondary font, Lusitana, from next/font/google. Make sure to specify the subset and font weight (refer to the Google Fonts website or TypeScript errors for available options).
Apply to Specific Element(s): Apply the lusitana.className to the desired elements in your application (e.g., the <p> element in app/page.tsx).
Additional Tips 

Consult the Google Fonts website to explore font options and available weights.
Refer to the Next.js documentation for details on adding multiple fonts and advanced configuration.


b) Image Optimization
Why Optimize Images? 

Images are often the largest assets on a website. 
Unoptimized images lead to slow loading times and a poor user experience. 
Challenges with Traditional Image Handling 

Responsiveness: Ensuring images adapt to various screen sizes can be complex.
Size Management: Specifying different image sizes for different devices is often manual.
Layout Shift: Images loading at different times can cause disruptive layout shifts.
Lazy Loading: Implementing lazy loading to improve initial page load times requires extra effort.
Next.js Image Optimization with the <Image> Component 

The next/image component extends the standard HTML <img> tag, providing automatic image optimization features:

Layout Shift Prevention: The component reserves space for images, preventing layout shifts as they load. 
Automatic Resizing: Images are resized to fit different viewports, reducing the need to deliver large images to devices with smaller screens. 
Built-in Lazy Loading: Images are lazy-loaded by default, meaning they load only when they enter the user's viewport. This optimizes initial page load time. 
Modern Format Support: The component serves images in modern formats like WebP and AVIF when supported by the browser, improving image quality and compression. 

Adding an Image 
Import the <Image> component: Import the Image component from next/image into the file where you want to use it.
Use the Component: Add the <Image> component, providing the src, width, height, and alt attributes. Ensure the width and height attributes match the aspect ratio of the source image to prevent layout shift.
// /app/page.tsx
import Image from 'next/image';

// ...
<Image
    src="/hero-desktop.png"
    width={1000}
    height={760}
    className="hidden md:block"
    alt="Screenshots of the dashboard project showing desktop version"
/>
Handling Different Images for Mobile and Desktop 

Provide Separate Images: Place different images for desktop and mobile in the /public folder (e.g., hero-desktop.png and hero-mobile.png).
Conditional Rendering: Use CSS classes like hidden and md:block to control the display of images based on screen size. For example, hidden md:block would hide the image on mobile and show it on desktop.

----------------------------------------------------------------------------------------------

#? Chapter 4: Creating Layouts and Pages

Creating Layouts and Pages in Next.js
This section of the documentation explains how to use Next.js features to structure your application with multiple routes and layouts for a better user experience. Here is a breakdown of the key concepts.

File-System Routing
Next.js uses a file-system based routing system, where folders represent route segments. Each folder within the /app directory maps to a corresponding URL segment in your application. For example:

The /app/dashboard folder corresponds to the /dashboard route.
A file named page.tsx within the /app/dashboard folder would be the page accessible at the /dashboard URL.
The page.tsx File
The page.tsx file is a special Next.js file that defines the content of a page. It exports a React component which is rendered when a user visits the corresponding route. Every route must have a page.tsx file to be accessible. Your application's home page is defined in the /app/page.tsx file, which is associated with the root route (/).

Creating Nested Routes
To create a nested route in your application, you simply create a new folder within an existing route folder and add a page.tsx file inside the new folder. For example, to create a page accessible at /dashboard/customers, you would:

Create a folder named customers inside the /app/dashboard folder.
Create a file named page.tsx within the /app/customers folder and define the content for the customers page.
Colocation
Next.js promotes the concept of "colocation," which means keeping related files together. You can place components, test files, and other code related to a specific route within the same folder as the page.tsx file. However, only the code within page.tsx is publicly accessible. This helps to organize your project and make it easier to maintain.

Layouts
Layouts allow you to create shared UI elements that are common across multiple pages. Next.js uses a special file named layout.tsx for defining layouts. A layout.tsx file exports a React component that receives a children prop. The content of the page.tsx file for the corresponding route is rendered as the children within the layout.

Nested Layouts
Layouts can be nested to create a hierarchy of shared UI components. For example, you can create a layout specific to your dashboard pages at /app/dashboard/layout.tsx that wraps the content of all pages within the /dashboard route. This allows you to have a consistent navigation or sidebar across all dashboard pages.

Partial Rendering
When navigating between pages that share a common layout, Next.js only updates the content within the page.tsx file while the layout component remains unchanged. This optimization, called partial rendering, improves performance by avoiding unnecessary re-renders of the entire page.

Root Layout
The root layout, located at /app/layout.tsx, is a special layout that wraps all pages in your application. It's primarily used for applying global styles and settings, like importing fonts or defining metadata. The root layout is required in every Next.js application.

----------------------------------------------------------------------------------------------

#? Chapter 5: Navigating Between Pages

Next.js Navigation Optimization
This section of the documentation explains how Next.js optimizes navigation between pages in an application to provide a smooth user experience that feels more like a web app than a traditional website.

Traditional Navigation Drawbacks: Using standard <a> HTML elements for navigation causes a full page refresh every time a user clicks a link. This leads to a less responsive experience and can feel jarring to the user.
The Link Component: Next.js provides a <Link /> component that enables client-side navigation with JavaScript, eliminating the full page refresh issue. The syntax is similar to using an <a> tag, simply replacing <a href="..."> with <Link href="...">. 

Automatic Code Splitting and Prefetching: Next.js enhances performance by automatically splitting your application's code into smaller chunks based on route segments. Unlike traditional single-page applications (SPAs) where the entire application code is loaded upfront, Next.js only loads the code needed for the current route. This results in faster initial page loads and better resource management. 
Route Isolation: Code splitting isolates pages, so an error on one page won't affect the functionality of other parts of the application.
Prefetching: When a <Link> component appears in the viewport, Next.js prefetches the code for the linked route in the background. This means that when a user clicks the link, the page transition is almost instantaneous because the code is already loaded.
Active Link Styling: A common UI pattern is to highlight the currently active link in the navigation menu.
usePathname() hook: You can use the usePathname() hook from next/navigation to get the user's current path from the URL. Since this is a hook, the component where you use it must be a Client Component. You indicate a component is a Client Component by adding "use client" to the top of the file.
Conditional Styling: By comparing the value returned by usePathname() to the href attribute of your <Link> components, you can apply CSS classes to style the active link. This helps users easily understand their current location within the application.

#? Chapter 6: Setting Up Your Database

This section of the sources provides a step-by-step guide on setting up a PostgreSQL database for your Next.js application using Vercel's marketplace integrations. It assumes you are using GitHub for your repository, but alternatives like GitLab or Bitbucket are also compatible. The instructions walk through pushing your project to GitHub, creating a Vercel account, deploying your project, and setting up and seeding your database.

Connecting your Project to GitHub and Vercel
1. Push Your Code to a GitHub Repository: If you haven't already, start by pushing your Next.js project to a GitHub repository. This step is essential for seamless integration with Vercel's deployment and database provisioning tools. 

2. Sign Up for Vercel and Link Your GitHub Account: Create a free "hobby" plan account on Vercel by visiting vercel.com/signup. To connect your GitHub and Vercel accounts, select the "Continue with GitHub" option. 

3. Import and Deploy Your Project: After connecting your accounts, Vercel will prompt you to import the GitHub repository you created. Choose a name for your project and click "Deploy" to initiate the deployment process. This action creates a live version of your application hosted on Vercel's platform. 

Automatic Redeployment on GitHub Push: Connecting your GitHub repository to Vercel enables automatic redeployment whenever you push changes to the main branch. Additionally, creating pull requests will generate instant previews, allowing you to catch deployment errors early and share a preview of your project with your team for feedback. 

Creating and Seeding your PostgreSQL Database
1. Create a PostgreSQL Database: Go to the "Storage" tab in your Vercel project dashboard and click "Create Database." You'll have options to choose from Postgres (Powered by Neon), Neon, or Supabase. Select your preferred provider and proceed by clicking "Continue." 

2. Connect to the Database and Configure Environment Variables: Accept the terms of service, choose your desired region (Washington D.C. (iad1) is recommended for lower latency), and select a plan if needed. After successfully connecting, go to the .env.local tab within your Vercel dashboard, click "Show secret" to reveal your database credentials, and then click "Copy Snippet." In your code editor, locate the .env.example file and rename it to .env. Paste the copied content from Vercel into this file. 

Protect your Secrets: To prevent your database credentials from being exposed when pushing to GitHub, add the .env file to your .gitignore file. 

3. Install the Vercel Postgres SDK: Execute the command "pnpm i @vercel/postgres" in your terminal to install the Vercel Postgres SDK. This SDK simplifies database interactions within your Next.js application. 

4. Seed Your Database with Initial Data: Within the /app folder of your project, you'll find a /seed folder that contains a Next.js Route Handler (route.ts). Uncomment this file. This handler acts as a server-side endpoint designed to populate your database. It uses SQL to create the necessary tables and draws data from the placeholder-data.ts file to fill them. 

5. Run the Seed Script: Ensure that your local development server is running (using pnpm run dev) and then visit localhost:3000/seed in your web browser. You should see a message confirming "Database seeded successfully." Once seeding is complete, you can safely delete the seed file. 

Additional Information about the Database
The sources mention that the seeding script uses the bcrypt library to hash user passwords for security purposes. If you encounter compatibility issues with bcrypt in your development environment, you can modify the script to use bcryptjs instead. 

Troubleshooting Database Seeding: The sources offer some troubleshooting tips for common database seeding issues. If you need to rerun the seeding script and there are existing tables, you can remove them using the DROP TABLE tablename command in your database query interface. However, exercise caution as this command will delete the specified table and all its associated data. While this is acceptable in a development environment with placeholder data, avoid using it in production applications. 

Executing Queries to Test the Setup: To verify that everything is functioning correctly, you can execute queries using another Router Handler located at /query/route.ts. This file contains a listInvoices() function with a sample SQL query. Uncomment this file and visit localhost:3000/query in your browser. The page should display the results of the query, returning an invoice amount and name. 

Conclusion
By following these steps, you'll have a PostgreSQL database set up and integrated into your Next.js project, ready for you to continue building your application.


-------------------------------------------------------------------------------------------------------------------------------